rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a strict user-centric security model.
     * Each user owns and controls their primary data, including their user document,
     * profile, videos, subscription, and credit balance. Access to shared resources,
     * such as matches and chats, is restricted to the specific participants involved.
     *
     * Data Structure: The data is organized into top-level collections for each
     * major entity (e.g., users, user_profiles, matches). This flat hierarchy
     * promotes scalability and simplifies rule logic. Relationships between documents
     * are established using denormalized user IDs (e.g., a 'userId' field on a
     * subscription document), which is critical for writing performant and secure rules
     * without costly cross-document reads.
     *
     * Key Security Decisions:
     * - User Ownership: The default security posture is owner-only access.
     * - Shared Access: Data shared between users (matches, chats) is secured by
     *   checking a list of participant UIDs stored directly on the shared document.
     * - Public Reads, Private Writes: Collections that need to be discoverable by other
     *   users for the app to function (e.g., user_profiles, videos) are publicly
     *   readable but are only writable by their designated owner.
     * - Write-Once Collections: Collections like 'reports' are designed to be
     *   write-once for users, who cannot read or modify them after submission.
     *
     * Denormalization for Authorization: To ensure performant authorization,
     * ownership and membership data is denormalized. For example, 'user_profiles'
     * and 'videos' documents must contain a 'userId' field to assert ownership.
     * Similarly, 'matches' contain 'user1Id' and 'user2Id' fields to grant access
     * to the two participants without needing extra lookups.
     *
     * Structural Segregation: User authentication data ('users') is kept in a
     * separate collection from publicly-viewable profile data ('user_profiles').
     * This separation ensures that sensitive information is not accidentally exposed
     * and allows for a simpler, more secure ruleset for each collection.
     */

    // --------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for establishing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document currently exists in Firestore.
     * Crucial for protecting update and delete operations from acting on null data.
     */
    function documentExists() {
      return resource != null;
    }

    /**
     * A composite function for update/delete operations, ensuring the user
     * is the owner and the document already exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && documentExists();
    }

    /**
     * Validates that the user making the request owns the document being created.
     * It checks the incoming data ('request.resource.data').
     */
    function ownsIncomingDoc(ownerField) {
      return isSignedIn() && request.auth.uid == request.resource.data[ownerField];
    }
    
    /**
     * Ensures a specific field on a document is immutable and cannot be changed during an update.
     */
    function isImmutable(field) {
      return request.resource.data[field] == resource.data[field];
    }

    // --------------------------------------------------------------------------
    // User Collections
    // --------------------------------------------------------------------------

    /**
     * @description Controls access to a user's private data document.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own user document.
     * @deny (get) A user trying to read another user's private data.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Disallow listing all users for privacy and security.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && isImmutable('id');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user profiles, which are publicly readable but only owner-writable.
     * @path /user_profiles/{profileId}
     * @allow (get) Any user, authenticated or not, can view a user profile.
     * @deny (update) A user attempting to modify another user's profile.
     * @principle Implements public read with owner-only writes.
     */
    match /user_profiles/{profileId} {
      // CRITICAL: This rule assumes a 'userId' field exists on user_profile documents for ownership checks.
      allow get, list: if true; // Profiles must be public for a dating app.
      allow create: if ownsIncomingDoc('userId');
      allow update: if isExistingOwner(resource.data.userId) && isImmutable('userId');
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Manages AI-generated videos, which are public but owner-controlled.
     * @path /videos/{videoId}
     * @allow (get) Any user, authenticated or not, can view a video.
     * @deny (delete) A user trying to delete another user's video.
     * @principle Implements public read with owner-only writes.
     */
    match /videos/{videoId} {
      // CRITICAL: This rule assumes a 'userId' field exists on video documents for ownership checks.
      allow get, list: if true; // Videos must be public for swiping.
      allow create: if ownsIncomingDoc('userId');
      allow update: if isExistingOwner(resource.data.userId) && isImmutable('userId');
      allow delete: if isExistingOwner(resource.data.userId);
    }

    // --------------------------------------------------------------------------
    // Matching and Chat Collections
    // --------------------------------------------------------------------------

    /**
     * @description Manages like actions between users.
     * @path /likes/{likeId}
     * @allow (list) Signed-in users can query for likes to check for matches.
     * @allow (create) A user can create a 'like' document for another user.
     * @deny (read, update, delete) Users cannot read likes directly or modify them.
     * @principle Enforces that users can only "like" others, and not tamper with the system.
     */
    match /likes/{likeId} {
      // NOTE: list is allowed, but client queries MUST be secured
      // with `where` clauses to prevent over-fetching.
      allow list: if isSignedIn();
      allow get: if false; // No direct document reads needed by client.
      allow create: if ownsIncomingDoc('swiperId');
      allow update, delete: if false; // Likes are immutable.
    }

    /**
     * @description Secures a match document, restricting access to the two participants.
     * @path /matches/{matchId}
     * @allow (get) One of the matched users reading the match document.
     * @deny (get) A third-party user trying to read someone else's match data.
     * @principle Enforces shared access for a closed set of collaborators.
     */
    match /matches/{matchId} {
      function isParticipant() {
        return isSignedIn() && (request.auth.uid == resource.data.user1Id || request.auth.uid == resource.data.user2Id);
      }
      function isIncomingParticipant() {
        return isSignedIn() && (request.auth.uid == request.resource.data.user1Id || request.auth.uid == request.resource.data.user2Id);
      }
      
      allow get: if isParticipant();
      // NOTE: list is allowed for signed-in users. Client queries MUST be secured 
      // to only fetch matches where the user is a participant.
      allow list: if isSignedIn();
      allow create: if isIncomingParticipant();
      allow update: if false; // Matches should be immutable.
      allow delete: if isParticipant() && documentExists();
    }

    /**
     * @description Secures the parent chat document, which holds participant info and last message.
     * @path /chats/{chatId}
     * @allow (get, list) A user who is a participant in the chat.
     * @deny (get) A user trying to access a chat they are not part of.
     * @principle Uses a parent document to efficiently secure a subcollection and denormalize data.
     */
    match /chats/{chatId} {
      // This rule assumes a 'participants' array of UIDs exists on this document for updates.
      function isChatParticipant() {
        return isSignedIn() && request.auth.uid in resource.data.participants;
      }
      
      function isChatParticipantById() {
        // The chatId is a composite key of two sorted user UIDs, e.g., "uid1_uid2".
        // This rule ensures the requesting user is one of those two UIDs.
        return isSignedIn() && request.auth.uid in chatId.split('_');
      }

      // NOTE: list is allowed for signed-in users. Client queries MUST be secured 
      // with a `where('participants', 'array-contains', request.auth.uid)` clause.
      // Get is allowed based on ID so the client can check for existing chats without error.
      allow get: if isChatParticipantById();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participants;
      // Allow participants to update the chat doc (e.g., for lastMessage).
      allow update: if isChatParticipant();
      allow delete: if false; // Chats should be archived, not deleted by users.
    }

    /**
     * @description Secures chat messages based on the chatID.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list, create) A chat participant.
     * @deny (list) A non-participant trying to list messages in a private chat.
     * @principle Enforces subcollection security by validating the user's UID against the composite chatID. This avoids a required get() on a parent document that may not exist yet.
     */
    match /chats/{chatId}/messages/{messageId} {
      function isChatParticipantById() {
        // The chatId is a composite key of two sorted user UIDs, e.g., "uid1_uid2".
        // This rule ensures the requesting user is one of those two UIDs.
        return isSignedIn() && request.auth.uid in chatId.split('_');
      }

      allow get, list: if isChatParticipantById();
      allow create: if isChatParticipantById() && ownsIncomingDoc('senderId');
      allow update, delete: if isChatParticipantById() && isExistingOwner(resource.data.senderId);
    }

    // --------------------------------------------------------------------------
    // Monetization and Safety Collections
    // --------------------------------------------------------------------------

    /**
     * @description Manages user subscription data, accessible only to the owner.
     * @path /subscriptions/{subscriptionId}
     * @allow (get) A user reading their own subscription status.
     * @deny (create) A user trying to create a subscription for someone else.
     * @principle Enforces document ownership for writes.
     */
    match /subscriptions/{subscriptionId} {
      // NOTE: list is allowed for signed-in users, but client queries MUST be secured
      // with a `where('userId', '==', request.auth.uid)` clause.
      allow get: if isOwner(subscriptionId);
      allow list: if isSignedIn();
      allow create: if ownsIncomingDoc('userId');
      allow update: if isExistingOwner(resource.data.userId) && isImmutable('userId');
      allow delete: if isExistingOwner(resource.data.userId);
    }
    
    /**
     * @description Manages a user's credit balance. Readable by user, writable only by server.
     * @path /credit_balances/{creditBalanceId}
     * @allow (get) A user reading their own credit balance.
     * @deny (update) A user attempting to give themselves more credits.
     * @principle Enforces document ownership for reads and restricts writes.
     */
    match /credit_balances/{creditBalanceId} {
      // NOTE: list is allowed, but client queries must be secured with `where('userId', '==', request.auth.uid)`.
      allow get: if isOwner(creditBalanceId);
      allow list: if isSignedIn();
      allow create: if ownsIncomingDoc('userId'); // Initial creation might be allowed.
      allow update: if false; // Balances must be updated by a trusted server environment.
      allow delete: if false;
    }

    /**
     * @description Manages user-submitted reports. Users can only create them.
     * @path /reports/{reportId}
     * @allow (create) A user submitting a report about another user.
     * @deny (get) The reporter trying to read their own report after submission.
     * @principle Implements a secure "write-once, read-never" pattern for users.
     */
    match /reports/{reportId} {
      allow get: if false;
      allow list: if false;
      allow create: if ownsIncomingDoc('reporterId') && request.resource.data.reporterId != request.resource.data.reportedId;
      allow update: if false;
      allow delete: if false;
    }
  }
}
